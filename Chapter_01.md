## 1장. 컴퓨터 내부의 언어 체계
> 프로그래머란 컴퓨터에게 명령을 내리는 일  
 -> 컴퓨터의 언어를 배워야 한다.
### 언어란 무엇인가
- 언어 : **정보**를 서로 **소통**하기 위해 만들어진 것.  
의사소통하는 당사자들이 모두 같은 **문맥**을 공유해야 한다.
#### 문자언어
- 문자 언어 : **기호를 나열**하여 정보를 전달하는 것  
- 문자 언어의 틀  
  1. 기호가 들어갈 **상자**
  2. 상자에 들어갈 **기호**
  3. 상자의 **순서** 
### 비트
- 자연어의 상자 : 문자  
- 컴퓨터의 상자 : 비트 Bit  

- 비트 bit : 2진법을 사용한다는 뜻의 binary와 숫자를 뜻하는 digit의 합성어  
### 논리 연산
- 논리 연산 logic operation
  - 다른 비트들이 표현하는 내용으로부터 **새로운 비트**를 만들어내는 연산  
  - 0 : 아니요 / 거짓 / false  
  - 1 : 예 / 참 / true  
#### 불리언 대수
- 불리언 대수 : 비트에 대해 사용할 수 있는 **연산 규칙**의 집합  
결합 법칙 / 교환 법칙 / 분배 법칙

  - NOT  
    - 논리적 반대. 비트의 의미를 반대로 바꾸는 연산.
  - AND  
    - 둘 이상의 모든 비트가 모두 참일경우에 참, 그 중 하나라도 거짓이면 거짓
  - OR  
    - 다수의 비트 중 하나라도 참 이면 참, 모든 비트가 모두 거짓이면 거짓
  - XOR : 배타적(Exclusive) OR.  
    - 두 개의 비트 입력을 기준으로 비트 중 하나만 참이면 참, 두 비트가 모두 참이거나 거짓이면 거짓 -> "배타"의 의미를 생각할 것.  
    - 주의  
  XOR의 이름이 두 입력만 받을 경우를 기준으로 지어졌다고  
  둘  이상의 입력을 못 받지는 않는다.  
  3 입력 이상의 경우 입력된 참이 홀수 개면 참, 짝수 개면 거짓.  

>- 진리표 truth table : 불리언 연산을 시각적으로 보여주는 표. 바깥이 입력, 안이 출력.

> 여기에 진리표 이미지를 넣을까 합니다.
#### 드모르간의 법칙
- A AND B == NOT(NOT A OR NOT B)  
  -  AND 연산을 OR 연산으로, 또는 그 반대로도 대체가 가능해진다.  
  - 정논리와 부논리  
  - 위의 성질을 이용해 입력의 형태에 무관하게 연산을 최소화할 수 있다.
### 정수를 비트로 표현하는 방법

#### 양의 정수 표현
- **LSB** : 가장 작은 유효 비트 least significant bit   
  - 가장 오른쪽의 작은 자릿수 비트  
- **MSB** : 가장 큰 유효 비트 most significant bit  
  - 가장 왼쪽의 큰 자릿수 비트  
- 리딩 제로 leading zero
  - 어떤 값을 표현하는데 필요 최소한의 비트 수보다 왼쪽에 더 추가된 비트(0)
  - 컴퓨터가 미리 [정해진 수의 비트](###-비트-그룹의-이름)를 한 덩어리로 사용하기 때문.  
#### 2진수 덧셈
- 2진수의 덧셈은 각 비트를 LSB(오른쪽)에서부터 MSB(왼쪽)으로 더하며 결과가 1보다 크면 1을 다음 자리(왼쪽)로 올린다. 
  - 두 비트를 서로 **더한 결과** == 두 비트의 **XOR** 결과
  - 두 비트를 서로 **더한 올림** == 두 비트의 **AND** 결과
- 덧셈 결과가 비트 범위 수를 벗어나면 **오버플로 overflow**가 발생한다.
- 오버플로 overflow : MSB에서 올림이 발생했다.
  - ex) 4비트 덧셈에서 1001과 1000을 더한 결과 10001은 0001로 표현됨.
> 컴퓨터에는 조건(상태) 코드 레지스터라는게 있어서 오버플로 비트에 MSB에서의 올림값이 들어간다. => 이 비트값으로 오버플로가 발생했는지 확인할수 있음.  
#### 음수 표현

##### 부호와 크기
- 음수 양수를 구분하기 위해 **부호 sign**를 사용
- 가장 왼쪽 비트(MSB)를 부호로 사용하기로 정해짐
  - 비트가 0 : 양의 부호
  - 비트가 1 : 음의부호
- 부호와 크기 표현법 : MSB를 부호, 나머지 비트를 절댓값으로 사용
- 문제점  
  1. 0을 표현하는 방법이 두 가지 => 비용 낭비
  2. XOR과 AND를 통한 덧셈이 불가

##### 1의 보수
- 1의 보수 : 양수의 모든 비트를 NOT 연산으로 뒤집는 방법
- 문제점  
  1. 0을 두 가지 방식으로 표현
  2. 덧셈이 어려움 : MSB의 올림을 LSB로 전달 => 순환 올림 end-around carry
##### 2의 보수
- 2의 보수 : 양수에 더했을 때 0이 나오는 비트 패턴의 탐색 => 음수
  - 음수의 비트 패턴은 양수의 모든 비트에 NOT 연산을 한 후 LSB에 +1을 한 결과와 같다. 이때 MSB의 올림은 버린다.
  1. 0을 표현하는 방법이 하나뿐이고
  2. XOR과 AND를 통한 덧셈이 가능하다.
#### 실수 표현

##### 고정소수점 표현법
- 고정소수점 표현법 : 소수점의 위치를 임의로 지정. 비트 사이의 소수점의 위치가 항상 일정하다.
- 실숫값을 표현하기에 필요한 비트 수가 너무 많다 => 메모리 비용
- 디지털 신호 처리 장치 DSP 등에 쓰인다.
##### 부동소수점 표현법
- 부동소수점 표현법 : 과학적 표기법을 적용, 수를 가수와 밑, 지수로 나누어 표현한다.
  - 가수 : 소수점 왼쪽이 한 자리뿐인 소수
  - 밑 : 거듭제곱하여 곱할 수
  - 지수 : 거듭제곱할 횟수
- 지수와 가수로 수를 분리 => 비트 수를 아끼고 큰 수, 작은 수를 표현 가능.
- 밑은 2로 고정 => 비트로 표현할 필요가 없다.
- 문제점  
  1. 겹치는 표현이 많다.
  2. 가능한 모든 수를 표현하진 못한다.
##### IEEE 부동소수점 수 표준 (IEEE 754)
- 실수를 표현하는 표준 방법
- 같은 비트를 사용하더라도 **정밀도**를 가능한 한 높이고 싶다.
  1. 정규화 nomalization  
  가수의 맨 왼쪽에 0이 없게 만듦
  2. 가수의 맨 왼쪽 비트가 1이라는 사실을 알고 있으므로, 이를 **생략**  
- 기본 정밀도 부동소수점 수
  -  32비트 사용, 7비트 정밀도  
    약 $\pm10^{\pm38}$ 범위  
- 2배 정밀도 부동소수점 수  
  -  64비트 사용, 15비트 정밀도  
    약 $\pm10^{\pm308}$ 범위
- 편향된 지숫값  
  - 지수 비트값 - 편향값을 계산하여 표현하는 지숫값을 구한다.  
    - 기본 정밀도 편향값 = 127
    - 2배 정밀도 편향값 = 1023
    - ex) 기본 정밀도 지수 01111111 => 127 - 127 = 0.
  - 지수 비트가 모두 0이거나 1인 경우에 특별한 의미를 넣기 위함
  - IEEE 754는 이로써 여러 가지 특별한 비트 패턴을 제공
### 2진 코드화한 10진수 시스템
- 2진 코드화한 10진수 binary-coded decimal **BCD**
- 4비트를 사용해 10진 숫자 자릿수 하나를 표현  
  - 2진수에 비해 더 많은 비트를 사용
- 디스플레이, 가속도 센서 등 사용
### 2진수를 다루는 쉬운 방법

#### 8진 표현법
- 2진수 비트를 3개씩 묶어 8진 표현법(0~7)으로 사용
#### 16진 표현법
- 0~9, abcdef까지 16진수로 사용
- 2진수 비트를 4개씩 묶어 16진 표현법(0~f)으로 사용
#### 프로그래밍 언어의 진법 표현법
1. 0으로 시작하는 수는 8진수이다 ( ex) 017은 8진수이고 10진수로 15이다.)
2. 1부터 9사이의 숫자로 시작하는 수는 10진수이다.
3. 0x가 앞에 붙는 수는 16진수이다. (0x12f는 16진수이고 10진수로 303이다)
### 비트 그룹의 이름
- 8 비트 덩어리가 기본 단위로 널리 쓰이기 시작했고 이를 **바이트 byte**라고 부른다.
- nibble  == 4 bit
- byte == 8 bit
- half word == 16 bit
- word == 32 bit
- double word == 64 bit
- kilobyte == 2^10 bit
- megabyte(MB or B) == 2^20 bit
- gigabyte(GB or G) == 2^30 bit 
- terabyte(TB or T) == 2^40 bit
- 워드 word : 각 컴퓨터 설계상 빠르게 처리할 수 있는 가장 큰 비트 덩어리
### 텍스트 표현

#### 아스키 코드
- 정보 교환을 위한 미국 표준코드
- 키보드의 모든 기호에 7비트 수 값을 할당 (p.79 표 참조)
- 장치를 제어하는 데 쓰이는 **제어문자**도 존재 (p.80 표 참조)
> - 유니코드 : 16비트로 지구상 모든 문자를 표현하고자 함  
    => 21비트까지 확장
#### 유니코드 변환 형식 8비트 (UTF-8)
- 유니코드의 16비트는 아스키 문자를 표현하기엔 8비트 낭비
- 유니코드는 문자 코드에 따라 각기 다른 **인코딩**을 통해 이 낭비를 해결  
  - 인코딩 : 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴
- UTF-8(유니코드 변환형식 8비트)이 가장 널리 사용됨 (p.82참조)
  - 유니코드의 비트 패턴을 여러 개의 8비트 덩어리(옥텟)으로 잘라 인코딩
### 문자를 사용한 수 표현

#### 출력 가능하게 변경한 인코딩 (QP인코딩)
- 8비트 데이터를 7비트 데이터만 지원하는 통신 경로에서 송수신하기 위한 인코딩
- 전자우편 첨부를 처리하기 위함.
> 자세한 규칙은 적지 않겠습니다. 추가하시려면 추가해주세요.
#### 베니스64 인코딩
- QP 인코딩의 비효율성을 해결
  - 1바이트를 3바이트로 표현 -> 3바이트를 4바이트로 변환
- 마찬가지로 전자우편 첨부파일 전송에 많이 사용 중.
#### URL 인코딩
- URL에서는 몇몇 문자가 특별한 의미를 지닌다.
- 그 문자들을 **문자 그대로 literal** 사용
  - % 뒤에 문자의 16진 표현
  - 퍼센트 인코딩
### 색을 표현하는 방법
- 컴퓨터 그래픽스 : 전자 모눈종이에 색 표현 **점 blob**을 찍어 그림을 만드는 과정
  - 점 => 그림 원소 picture element => 줄여서 **픽셀 pixel**  
- RGB색 모델
  - 빨간색 R, 녹색 G, 파란색 B의 광선을 섞어 색을 만드는 표현법
  - 컬러 큐브로 표현 가능 : 각 축은 주(primary)색을 표현한다.
  - 0 ~ 1로 빛의 세기를 표현
  - 빛을 혼합하는 **가산 색 시스템**
  - 감산에 비해 더 많은 색을 만들 수 있다.
- 감산 색 시스템 (물감 혼합)
  - 주색 : 청록(사이언), 자홍(마젠타), 노랑(옐로우)
  - 흰 색에서 각 색에 해당하지 않는 빛을 제거하여 색을 만듦
  - 가산에 비해 많은 색을 만들어 낼 수 없다.
#### 투명도 추가
- 색의 표현에 24비트 사용
  - 8비트씩 각 색(RGB)에 할당 -> 24비트
  - 1워드(32비트)에 넣어 처리
    - 남는 8비트
- 투명도 transparency
  - 여러 이미지를 합성하고 결합할 수 있는 정도
  - 알파 : 0 이상 1 이하인 값
    - 0 : 완전히 투명
    - 1 : 완전 불투명
    - 위의 남는 8비트 사용 (1 -> 255) 
#### 색 인코딩
- 텍스트로 색을 표현할 방법
  - 16진 트리플렛
  - #뒤에 여섯 자리 16진 숫자를 추가
  - #rrggbb